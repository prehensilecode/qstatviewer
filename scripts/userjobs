#!/usr/bin/env python
"""
Print out given user's jobs in a QstatViewer instance
"""

# Author: David Chin <dwchin@acm.org>

# Copyright 2013 Wake Forest University

import sys
import os
import datetime
import getpass
from optparse import OptionParser

import qstatviewer as qv

total_ncpus_used = 0
total_nodes_used = 0
total_cput_usage = datetime.timedelta()
total_mem_usage = 0.
n_running = 0

def print_cluster_summary(q):
    nnodes = 0
    ncpus  = 0
    for nodename,node in q.nodes.iteritems():
        if (not node.state == 'down') or (not node.state == 'offline'):
            nnodes += 1
            ncpus += node.ncpus

    print("Total available nodes: {nnodes:>3}    No. of CPUs: {ncpus:4}".format(nnodes=nnodes, ncpus=ncpus))
    

def print_jobinfo(q, jobids, uorg):
    # takes 
    # - q = qv.QstatViewer 
    # - jobids = list of job ids
    # - uorg = username or groupname
    global total_ncpus_used
    global total_nodes_used
    global total_cput_usage
    global total_mem_usage
    global n_running

    userjobs = q.jobs

    total_cpus_used = 0
    n_running = 0
    formatstr = "      {k:>9}: {v:>20}"
    run_formatstr = "      {k:>9}: {v:>20}      {k:>9}: {v2:>20}"
    run2_formatstr = "      {k:>9}: {v:>20}      {k2:>9}: {v2:>20}"
    for jobid in jobids:
        print("{0}:".format(jobid.split('.')[0]))
        print("           User: {0}".format(userjobs[jobid].owner))
        print("          State: {0}".format(qv.jobstate_dict[userjobs[jobid].job_state]))
        print("    Exec. hosts: {0}".format(userjobs[jobid].exec_host))
        print("    RESOURCES REQUESTED:                   RESOURCES USED:")

        rl = userjobs[jobid].resource_list
        ru = userjobs[jobid].resources_used

        if userjobs[jobid].job_state == 'R':
            n_running += 1
            ncpus = rl['ncpus']
            total_ncpus_used += ncpus

            total_nodes_used += len(userjobs[jobid].hosts)

            k = 'ncpus'
            v = rl[k]
            v2 = v
            print(run_formatstr.format(k=k, v=v, v2=v2))

            k = 'nodes'
            v = rl[k]
            #v2 = ''
            #print(run_formatstr.format(k=k, v=v, v2=v2))
            print(formatstr.format(k=k, v=v))

            k = 'mem'
            mem = qv.convert_memory(rl[k])
            v = "{q:<.2f} {u:3}".format(q=mem['qty'], u=mem['units'])
            mem = qv.convert_memory(ru[k])
            v2 = "{q:<.2f} {u:3}".format(q=mem['qty'], u=mem['units'])
            print(run_formatstr.format(k=k, v=v, v2=v2))

            k = 'pmem'
            pmem = qv.convert_memory(rl[k])
            v = "{q:<.2f} {u:3}".format(q=pmem['qty'], u=pmem['units'])
            k2 = 'vmem'
            vmem = qv.convert_memory(ru[k2])
            v2 = "{q:<.2f} {u:3}".format(q=vmem['qty'], u=vmem['units'])
            print(run2_formatstr.format(k=k, k2=k2, v=v, v2=v2))

            k = 'cput'
            (h,m,s) = rl[k].split(':')
            v = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
            (h,m,s) = ru[k].split(':')
            v2 = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
            total_cput_usage += datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
            print(run_formatstr.format(k=k, v=v, v2=v2))

            k = 'walltime'
            (h,m,s) = rl[k].split(':')
            v = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
            (h,m,s) = ru[k].split(':')
            v2 = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
            print(run_formatstr.format(k=k, v=v, v2=v2))

            print ""
            walltime_remaining = datetime.timedelta(seconds=userjobs[jobid].walltime_remaining) 
            print "    Walltime remaining (est.):", walltime_remaining

        else:
            k = 'ncpus'
            v = rl[k]
            print(formatstr.format(k=k, v=v))

            k = 'nodes'
            v = rl[k]
            print(formatstr.format(k=k, v=v))

            k = 'mem'
            mem = qv.convert_memory(rl[k])
            v = "{q:<.2f} {u:3}".format(q=mem['qty'], u=mem['units'])
            print(formatstr.format(k=k, v=v))

            k = 'pmem'
            pmem = qv.convert_memory(rl[k])
            v = "{q:<.2f} {u:3}".format(q=pmem['qty'], u=pmem['units'])
            print(formatstr.format(k=k, v=v))

            k = 'cput'
            (h,m,s) = rl[k].split(':')
            v = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
            print(formatstr.format(k=k, v=v))
    
            k = 'walltime'
            (h,m,s) = rl['walltime'].split(':')
            v = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
            print(formatstr.format(k=k, v=v))

        print("")

    print("Summary of {u}'s jobs: {n:>5d} running, {q:>5d} queued".format(u=uorg, n=n_running, q=(len(jobids)-n_running)))
    print("    Total no. of nodes occupied = {n}".format(n=total_nodes_used))
    print("     Total no. of CPUs occupied = {n}".format(n=total_ncpus_used))
    print("        Total CPU time consumed = {c}".format(c=total_cput_usage))
    print("")
    print_cluster_summary(q)

    # reset accumulators
    total_ncpus_used = 0
    total_cput_usage = datetime.timedelta()
    total_mem_usage = 0
    n_running = 0


def main(user=None, group=None, summary=False):
    global total_ncpus_used
    global total_cput_usage
    global total_mem_usage
    global n_running

    if not user and not group and not summary:
        user = [getpass.getuser()]

    q = qv.QstatViewer()


    if user:
        for u in user[0].split(','):
            userjobs = {}
            for jobid,job in q.jobs.iteritems():
                if job.owner == u:
                    userjobs[jobid] = job

            njobs = len(userjobs)
            if njobs == 1:
                jobstr = 'job'
            else:
                jobstr = 'jobs'

            print("{u} has {n} {j}".format(u=u, n=njobs, j=jobstr))
            print("")

            sorted_jobids = sorted(userjobs.keys())
            print_jobinfo(q, sorted_jobids, u)
    elif group:
        for g in group.split(','):
            groupjobs = {}
            for jobid,job in q.jobs.iteritems():
                if job.group_list[0] == g:
                    groupjobs[jobid] = job

            njobs = len(groupjobs)
            if njobs == 1:
                jobstr = 'job'
            else:
                jobstr = 'jobs'
            
            print("{u} has {n} {j}".format(u=g, n=njobs, j=jobstr))
            print("")

            sorted_jobids = sorted(groupjobs.keys())
            print_jobinfo(q, sorted_jobids, g)
    elif summary:
        print("    USER        GROUP NCPUS     TOTAL CPU TIME")
        print("-------- ------------ ----- ----------------------")
        users_jobs = {}
        for jobid,job in q.jobs.iteritems():
            if job.job_state == 'R':
                if job.owner not in users_jobs:
                    users_jobs[job.owner] = []
                users_jobs[job.owner].append(job)

        sorted_users = sorted(users_jobs.keys())
        #for u,jlist in users_jobs.iteritems():
        for u in sorted_users:
            group = users_jobs[u][0].group
            for job in users_jobs[u]:
                for k,v in job.resource_list.iteritems():
                    if k == 'ncpus':
                        total_ncpus_used += v
                for k,v in job.resources_used.iteritems():
                    if k == 'cput':
                        if v:
                            (h,m,s) = v.split(':')
                            total_cput_usage += datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))

            print("{u:>8.8} {g:>12.12} {n:>5} {t:>20}".format(u=u, g=group, n=total_ncpus_used, t=total_cput_usage))

            # reset accumulators
            total_ncpus_used = 0
            total_cput_usage = datetime.timedelta()
            total_mem_usage = 0.


if __name__ == '__main__':
    usage = """usage: %prog [options] [username[,username...]]
    Prints out information about all jobs of given user
    N.B. some jobs do not report CPU usage"""
    parser = OptionParser(usage)
    parser.add_option('-s', '--summary', action='store_true', default=False,
                      dest='summary', help='summary of all users with running jobs')
    parser.add_option('-g', '--group', type='str',
                      help='jobs belonging to group GROUP; may be a comma-separated list')
    (options, args) = parser.parse_args()

    main(user=args, group=options.group, summary=options.summary)

