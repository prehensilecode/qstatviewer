#!/usr/bin/env python
"""Displays information about one or more users' jobs"""

# Author: David Chin <dwchin . acm.org>

# qstatviewer by David Chin is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.
# http://creativecommons.org/licenses/by-sa/3.0/deed.en_US

import sys, os, re
import datetime
from optparse import OptionParser

import qstatviewer

def jobs_on_nodes(qv):
    print('{0}:'.format(qv.pbsquery.server))
    print("{j:<11} {u:<8} {g:>13} {q:<8} {jn:^24} {f:^5.3} NODES ".format(j="JOB ID", u="USERNAME", 
        g="GROUP", q="QUEUE", jn="JOBNAME", f="NET"));
    print("-----------------------------------------------------------------------------------------------------------------")
    formatstr = "{ji:<11} {job.owner:<8.8} {job.group:>13.13} {job.queue:<8.8} {job.name:^24.24} {fab:^5.3}"
    tmpset = set()
    for id in sorted(qv.jobs.keys()):
        job = qv.jobs[id]
        if job.job_state == 'R':
            #print "{0:<11.11}".format(id.split('.')[0]), "{0:>8.8}".format(job.owner), "{0:>13.13}".format(job.egroup), 
            nhosts = len(job.hosts)
            hostlist = list(job.hosts)
            if nhosts == 1:
                fabric = qv.nodes[hostlist[0]].fabric
            else:
                fabric = qv.nodes[hostlist[0]].fabric
                for n in range(1,nhosts):
                    curfabric = qv.nodes[hostlist[n]].fabric
                    if curfabric != fabric:
                        fabric = 'mix'
                        break
                    else:
                        continue
            print formatstr.format(ji=id.split('.')[0], fab=fabric, job=job),
            for h in sorted(job.exec_host):
                tmpset.add(h.split('/')[0])
            for h in tmpset:
                print h,
            print ''
            tmpset.clear()

    print''
    tmpset.clear()


def main(user=None, all=False, group=None, state=None, nodes=False):
    qv = qstatviewer.QstatViewer()

    if nodes:
        jobs_on_nodes(qv)
    else:
        print('{0}:'.format(qv.pbsquery.server))
        print("{j:<11} {u:<8} {g:>13} {q:<8} {jn:^24} {s:>6} {nd:>3} {t:>5} {f:^3.3} {mreq:>10} {treq:>16}  S {tel:>16}".format(j="JOB ID", u="USERNAME", 
            g="GROUP", q="QUEUE", jn="JOBNAME", s="SessID", nd="NDS", t="TSK", f='NET', mreq="REQ MEM", treq="REQ WALLTIME", tel="ELAP WALLTIME"));
        print("------------------------------------------------------------------------------------------------------------------------------------------")
    
        print_this_p = False

        dayspat = re.compile('\ days?,')

        for jobid, j in sorted(qv.jobs.iteritems()):
            nodect = j.resource_list['nodect']
            ntasks = j.resource_list['ncpus']
            mem    = qstatviewer.convert_memory(j.resource_list['mem'], 'gb')
            wallt_str = qstatviewer.timedeltastr(j.resource_list['walltime'])
    
            if user:
                #print 'FOOBAR: j.owner = ', j.owner
                if j.owner == user:
                    print_this_p = True
            elif group:
                if j.group == group:
                    print_this_p = True
            elif state:
                if state == 'r' or state == 'R':
                    state = 'R'
                elif state == 'q' or state == 'Q':
                    state = 'Q'
                if j.state == state:
                    print_this_p = True
            elif all:
                print_this_p = True
            else:
                print_this_p = True

            if j.state == 'R':
                if not j.resources_used:
                    # for some reason, some running jobs have no resources_used element
                    #print 'FOOBAR: id = ', jobid
                    #print 'FOOBAR:      ', j.resources_used
                    #print ''
                    elapse = 'n/a'
                    fabric = 'n/a'
                if j.resources_used:
                    elapse = qstatviewer.timedeltastr(j.resources_used['walltime'])
                    nhosts = len(j.hosts)
                    hostlist = list(j.hosts)
                    if nhosts == 1:
                        fabric = qv.nodes[hostlist[0]].fabric
                    else:
                        fabric = qv.nodes[hostlist[0]].fabric
                        for n in range(1,nhosts):
                            curfabric = qv.nodes[hostlist[n]].fabric
                            if curfabric != fabric:
                                print 'FOOBAR: curfabric = ', curfabric
                                print 'FOOBAR:    fabric = ', fabric
                                fabric = 'mix'
                                break
                            else:
                                continue
                        
            else:
                elapse = 'n/a'
                fabric = 'n/a'

            formatstr = "{ji:<11} {job.owner:<8.8} {job.group:>13.13} {job.queue:<8.8} {job.name:^24.24} {job.session_id:>6} {nodect:>3d} {ntasks:>5d} {fab:^3.3} {mem:>6.2f} {memunit:<3} {wallt:>16}  {job.job_state} {elapse:>16}"

            if print_this_p:
                print(formatstr.format(ji=jobid.split('.')[0], job=j, nodect=nodect, ntasks=ntasks, fab=fabric, mem=mem['qty'], memunit=mem['units'], wallt=wallt_str, elapse=elapse))
                print_this_p = False

if __name__ == '__main__':
    usage = """usage: %prog [options] [USERNAME]
        If USERNAME is given, only jobs belonging to USERNAME are displayed"""
    parser = OptionParser(usage)
    parser.add_option('-a', '--all', action='store_true', dest='all', default=False,
                      help='displays all jobs')
    parser.add_option('-g', '--group', dest='group', type='str', 
                      help='displays jobs for users in GROUP')
    parser.add_option('-s', '--state', dest='state', type='str',
                      help='displays jobs with state STATE')
    parser.add_option('-n', '--nodes', action='store_true', dest='nodes', 
                      default=False, help='displays nodes occupied by job')
    (options, args) = parser.parse_args()

    if not args and not options.all and not options.group and not options.state and not options.nodes:
        parser.print_help()
        sys.exit(1)

    if args:
        main(user=args[0])
    else:
        main(user=None, all=options.all, group=options.group, state=options.state, nodes=options.nodes)

